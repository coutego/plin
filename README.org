* Plin: A Data-Driven Plugin Architecture for ClojureScript

Plin is a functional, data-driven framework designed for building *Modular Monoliths* in ClojureScript. It provides a rigorous architectural boundary system that enforces loose coupling through *Inversion of Control (IoC)* and *Dependency Injection (DI)*.

Unlike traditional frameworks that rely on class-based inheritance or global singletons, Plin models the entire application structure—modules, dependencies, configuration, and extension points—as immutable data.

** Architectural Philosophy

As frontend applications scale, the "Import Graph" tends to resemble a plate of spaghetti. Components import stores, stores import services, services import utilities, and circular dependencies abound. Refactoring becomes risky, and testing in isolation becomes impossible.

Plin solves this by introducing a strict separation between *Wiring Time* and *Runtime*.

*** The Two-Phase Boot Process

1. *The Pluggable Phase (Wiring & Resolution)*
   - *Input*: A list of Plugin Maps.
   - *Process*:
     - *Topological Sort*: Resolves the Dependency Acyclic Graph (DAG) based on the ~:deps~ vector of each plugin.
     - *Extension Aggregation*: Iterates through the graph. If Plugin A defines an extension point (e.g., "Sidebar Items"), and Plugin B contributes to it, the system aggregates this data using a defined reducer function.
   - *Output*: A flat map of "Bean Definitions".

2. *The Injectable Phase (Instantiation)*
   - *Input*: The map of Bean Definitions.
   - *Process*:
     - *Container Construction*: Creates a DI container.
     - *Injection*: Dependencies are resolved and injected into functions via arguments or partial application.
   - *Output*: A running system where components hold references to their dependencies, not to global namespaces.

** Core Concepts

*** 2.1 The Plugin Map
A Plugin is the atomic unit of modularity. It is a Clojure map containing metadata, dependencies, and definitions.

#+BEGIN_SRC clojure
(def plugin
  (plin/plugin
   {:id            :my.sys/auth-module  ;; Unique ID (auto-generated from ns if omitted)
    :doc           "Authentication Module"
    :deps          [http/plugin         ;; Dependencies (other plugin vars)
                    logger/plugin]

    ;; 1. BEANS: Internal logic or exported services
    :beans         {::auth-service  [make-auth-service ::http/client]
                    ::login-form    [partial login-ui ::auth-service]}

    ;; 2. EXTENSIONS: Slots this plugin exposes for others to fill
    :extensions    [{:key ::auth-providers
                     :doc "Registry for OAuth providers."
                     :handler (plin/collect-all ::auth-providers)}]

    ;; 3. CONTRIBUTIONS: Data this plugin pushes into OTHER plugins' extensions
    :contributions {::sidebar/items [{:label "Login" :href "/login"}]}}))
#+END_SRC

** 2.2 Interface vs. Implementation
To enforce boundaries, Plin strongly encourages the *Interface/Implementation Pattern*.

- *Interface Plugin (`i-feature`)*:
    - Defines the *Contract*.
    - Declares Extension Points.
    - Defines abstract Beans (often with no-op or mock defaults).
    - Contains *NO* business logic or heavy UI code.
    - *Example*: `i-auth` defines `::user-service` (a map of functions) and `::login-form` (a nil placeholder).

- *Implementation Plugin (`p-feature`)*:
    - Depends on the Interface.
    - Provides the *Logic*.
    - Overrides the abstract Beans with concrete implementations.
    - *Example*: `p-auth-firebase` overrides `::i-auth/user-service` with Firebase logic.

*** 2.3 Beans & Injection Syntax
Beans are the runtime components managed by the container. Plin uses a concise vector syntax (DSL) to define them.

| Syntax | Type | Description |
|---|---|---|
| ~[:= value]~ | *Value*  | Injects the literal value (map, string, number). |
| ~[fn arg1 arg2]~ | *Factory*  | Calls ~(fn arg1 arg2)~ at container build time. The result is the bean. |
| ~[partial fn arg1]~ | *Partial*  | Returns ~(partial fn arg1)~. Crucial for React components (see below). |

*Note on Keys*: All keys must be fully qualified keywords (e.g., ~::my-service~). This prevents collisions in the global container.

** Developer Tutorial: Building a "Task Manager"

We will build a modular Task Manager where the logic, the UI, and the dashboard integration are decoupled.

*** Step 1: The Interface (`i-tasks`)
First, we define the contract. We declare that a "Task Service" and a "Task List UI" exist, but we don't implement them.

#+BEGIN_SRC clojure
(ns my-app.i-tasks
  (:require [plin.core :as plin]))

(def plugin
  (plin/plugin
   {:doc "Interface for Task Management."

    ;; We define an extension point for other plugins to add 'default tasks'
    :extensions
    [{:key     ::default-tasks
      :doc     "List of tasks to create on system init."
      :handler (plin/collect-all ::default-tasks)}]

    :beans
    {;; 1. The Service Contract (Default: No-op implementation)
     ::service
     ^{:doc "Map of functions: {:add (fn [t]), :list (fn [])}"}
     [:= {:add  (fn [_] (println "No-op add"))
          :list (fn [] [])}]

     ;; 2. The UI Contract (Default: Placeholder)
     ::list-ui
     ^{:reagent-component true}
     [:= (fn [] [:div "Task List Not Implemented"])]

     ;; 3. The Aggregated Default Tasks (Result of the extension)
     ::default-tasks
     [:= []]}}))
#+END_SRC

*** Step 2: The Implementation (`p-tasks-memory`)
Now we implement the logic using an in-memory atom. Note that we depend on `i-tasks`.

#+BEGIN_SRC clojure
(ns my-app.p-tasks-memory
  (:require [reagent.core :as r]
            [plin.core :as plin]
            [my-app.i-tasks :as i-tasks]))

;; --- Pure Logic / State ---

(defn make-service [default-tasks]
  (let [state (r/atom default-tasks)]
    {:add  (fn [task] (swap! state conj task))
     :list (fn [] @state)}))

;; --- UI Component ---

(defn task-list-view [service]
  (let [tasks ((:list service))]
    [:div
     [:h3 "My Tasks"]
     [:ul
      (for [t tasks]
        [:li {:key t} t])]
     [:button {:on-click #((:add service) "New Task")}
      "Add Task"]]))

;; --- Plugin Definition ---

(def plugin
  (plin/plugin
   {:doc  "In-Memory Implementation of Tasks."
    :deps [i-tasks/plugin]

    :beans
    {;; Override the Service
     ;; We inject the ::default-tasks bean (populated by extensions)
     ::i-tasks/service
     [make-service ::i-tasks/default-tasks]

     ;; Override the UI
     ;; We use 'partial' to inject the service into the component
     ;; without invoking the component function immediately.
     ::i-tasks/list-ui
     ^{:reagent-component true}
     [partial task-list-view ::i-tasks/service]}}))
#+END_SRC

*** Step 3: A Consumer Plugin (`p-dashboard`)
This plugin uses the Task List UI, but it has no idea that `p-tasks-memory` exists. It only knows `i-tasks`.

#+BEGIN_SRC clojure
(ns my-app.p-dashboard
  (:require [plin.core :as plin]
            [my-app.i-tasks :as i-tasks]))

(defn dashboard-view [task-list-component]
  [:div.dashboard
   [:h1 "Welcome Home"]
   ;; Render the injected component
   [task-list-component]])

(def plugin
  (plin/plugin
   {:doc "Dashboard Feature."
    :deps [i-tasks/plugin]

    ;; Contribute a default task to the i-tasks extension
    :contributions
    {::i-tasks/default-tasks ["Check Emails"]}

    :beans
    {::ui
     ^{:reagent-component true}
     [partial dashboard-view ::i-tasks/list-ui]}}))
#+END_SRC

** Advanced Patterns

*** 4.1 Reactivity and Partial Application
A common pitfall in DI with React is losing reactivity.

**Wrong:**
#+BEGIN_SRC clojure
:beans {::my-ui [my-component dependency]}
#+END_SRC
This calls `(my-component dependency)` *once* at build time. The result (a static Hiccup vector) is stored in the container. If the dependency is an atom, the component won't re-render when it changes because the dereference happened during the build.

**Correct:**
#+BEGIN_SRC clojure
:beans {::my-ui [partial my-component dependency]}
#+END_SRC
This stores a *function* `(partial my-component dependency)` in the container. When Reagent renders `[::my-ui]`, it executes the function, establishing the reactive bindings correctly.

*** 4.2 Extension Handlers
The `:handler` key in an extension definition takes a function `(fn [db contributions] -> db)`.
Plin provides helpers for common patterns:

- *`plin/collect-all`**: Flattens all contributions into a vector.
  - *Use case*: Menu items, Route definitions, Listeners.
- *`plin/collect-last`**: Takes the last contribution (LIFO).
  - *Use case*: Overriding a default configuration or a singleton widget.
- *`plin/collect-data`**: Like `collect-all` but optimized for static data (avoids runtime constructor overhead).

*** 4.3 The System Debugger
Plin includes a powerful introspection tool. Since the entire app is data, we can visualize it.
- *Plugin Graph**: See how plugins depend on each other.
- *Bean Graph**: See how beans are injected.
- *State Inspector**: View the current value of atoms inside the container.

To access it, ensure `plugins.p-debug` is loaded and navigate to `#/debug`.

** Best Practices

1.  *Naming*:
    - Interface plugins: `i-name`
    - Implementation plugin: `p-name`
2.  *Granularity*:
    - Plugins should be small and focused.
    - If a plugin does two unrelated things, split it.
3.  *No Cross-Implementation Imports*:
    - `p-dashboard` should NEVER require `p-tasks`. It should only require `i-tasks`.
    - If you break this rule, you lose the ability to swap implementations.
4.  *Fully Qualified Keys*:
    - Always use `::key` (which expands to `:current.ns/key`).
    - When referencing another plugin's bean, use `::alias/key`.

** License

Copyright Coutego © 2025
Distributed under the EUPL License.
